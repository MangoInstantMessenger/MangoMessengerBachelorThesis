# About tokens, JSON Web Tokens, authentication and authorization. Token-Based authentication

- What is authorization/authentication
- Where to store tokens
- How to set cookies
- Login process
- Refresh token process
- Theft of tokens/Token control mechanism
- JWT vs Cookie sessions

## Base

Authentication(from the Greek [authentikos] - real, genuine; by [authentes] - author) - it is process which verify user credentials, for instance login and password.
User authentication by comparing the login and password entered by him with the data saved in the database.
Authorization - it is process which check of the user's rights to access certain resources.

For example, after authentication the user Bob gets the right to access and get from resource https://resource.com some data.
When the user Bob accesses to the vip resource, the authorization system will check has the user right to access this resource. 

1. The user with email bob@gmail.com successfully authenticated.
2. The server checks in database roles of Bob.
3. The server generated token with specified role.
4. Bob go in a certain resource using received token.
5. The server check user rights in token and respectively skips or cuts the request.

The fifth point is the authorization.

JSON Web Token (JWT) contains 3 blocks separated by dots: header, payload and signature. 
The first 2 blocks presented in JSON-format and additionally encoded to the format base64.
Payload contains arbitary key-value pairs.
The JWT standard defines several reserved names (iss, aud, exp, and others).
Signature can be generated with help of symmetric and asymetric encryption algorithms.
In addition, there is a separate standard that describes the format of the encrypted JWT-token.
Tokens presents a means of authorization for every request from client to server.
Tokens are generatedon the server based on secret key which stored in the server and payload.
As a result, token stored on the client and used when it is necessary to authorize any requests.

When a hacker tries to replace the data in the header or payload, token will become invalid, since the signature will not match the original values.
And the hacker does not ability to generate a new signature, since the encryption secret key stored in the server.

Access Token is used for request authorization and for storing the additionally information about user, for example, User ID, Display Name and others.
This information is also called payload.
All payload fields is free set of fields necessary for implementation your private business logic.
That is User ID, Display Name is not required fields and presents only a special case.

Refresh Token issued by server based on successful authentication results and used for get new access/refresh token pair.

Every token has its own lifetime. 
For example, Access token lifetime may be 5 minutes, and Refresh token's 7 days.

Since tokens are not encrypted information, it is highly not recomended to store any sensitive data in them (password hashes, payment credentials, etc ...)

## Creating sessions

1. The user logs into the application by transferring the login, password and fingerprint of the browser (well, or some other unique device identifier if it is not a browser).
2. The server verifies the authenticity of the login and password.
3. If successful, creates and writes a session to the database, see table session in [reference database schema].
4. The server creates Access token.
5. Sends to client access token and refresh token (uuid).
6. Client saves the pair of access and refresh tokens to the local storage.

Before each request client preliminarily checks access token's lifetime and if it expired, client sends request for updating access token.
For more confidence, we can update tokens a few seconds earlier.
That is, the case when the API receives an expired access token is practically excluded.

To use the authentication feature on more than one device, it is necessary to store all refresh tokens for each user. 
I store this list in a PostgreSQL table.

1. Client before each request checks **access token** lifetime.
2. If it expired, client sends POST api/session/{Id}.
3. The server receives a record of the refresh session by the UUID of the refresh token.
4. The server saves current refresh session in the local storage and delete it from the table.
5. Checks current refresh session:
  1. Has token lifetime expired.
  2. To match the old fingerprint received from the current refresh session with the new one received from the request body.
6. In case of a negative result, throws an error TOKEN\_EXPIRED or INVALID\_REFRESH_SESSION.
7. If successful, it creates a new refresh session and writes it to the database.
8. The server creates access token.
9. Sends to client access and refresh token (uuid).

At the time of the refresh, that is, updates to the **access token**, both tokens are updated.
But how can a refresh token update itself, since it is created only after successful authentication?
The refresh token at the time of the refresh compares itself with the refresh token that is in the database and in case of success, 
and also if it has not expired, the system refreshes the tokens.

## JWT vs Cookie sessions
Why not use the good old cookie sessions? What's wrong with cookies?

- Cookie subject to CSRF: https://owasp.org/www-community/attacks/csrf
- It is more convenient for native applications for smartphones to work with tokens. Yes, there are hacks for working with cookies, but this is not native support.
- Cookies are not an option in microservice architecture.

Let remind you that microservices are often scattered on different domains, and cookies do not support cross-domain requests.

- In the microservices architecture, JWT allows each service, regardless of the authorization server, to verify the **access token** (via a public key).
- When using jwt, we see a security problem and try to provide control mechanisms in the event of a load of authorization data.
When using cookies, the programmer often does not even think that the session can be compromised.
- On every request, using JWT saves the backend from one request to the database (or cache) for user data (userId, email, etc.)

## Eventually
- Theft control mechanisms sensitive data in stock
- Took the best of both technologies, as much as possible secured against CSRF / XSS
- Add CSP header `SameSite=Strict` for cookie and wait the villains