\section{Web Service Architecture}\label{sec:web-service-architecture}

\subsection{Motivation}\label{subsec:motivation}
Implementing the instant messenger system, we consider applying a well-known N-tier
Monolithic Architecture [\cite{bucchiarone2018monolithic}], which provides a time-proven model that allows software
developers to create flexible and reusable applications.

However, during the implementation of monolith it is very important to avoid the cases of crucial over-engineering
of the system.
For the developers, it is a vital point to follow the KISS [\cite{alwin2016kiss}] and YAGNI [\cite{da2018evolution}]
software development principles in order not to reach
\href{https://github.com/smartstore/SmartStoreNET/blob/4.x/src/Presentation/SmartStore.Web/Controllers/CatalogHelper.cs}
{thousands lines}
of code in a single class.

One would suggest to use nowadays popular Microservices Architecture, thinking about scalability [\cite{brataas2004exploring}],
an ability of the system to handle large numbers of users distributed over geographically large areas without
notably affecting the overall performance of the system.
However, the effect of Microservices is being felt only for quite large and complex systems,
not the case of our yet simple application.
Following plot demonstrates this relation

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Pictures/Monolith_vs_Microservice.pdf}
    \caption{Relation between system complexity and architectures.
    Source: \href{https://martinfowler.com/bliki/MicroservicePremium.html}{Martin Fowler.}}
    \label{fig:monolith_vs_microservice}
\end{figure}

A layered architecture usually consists of Presentation layer, Business logic layer, Data access layer.
By segregating the project into layers, developers reach the options to modifying or add a specific layer,
without reworking the entire application.

\begin{itemize}
    \item \textbf{Presentation Layer.} Graphic user interface or API gateway.
    \item \textbf{Application Logic.} Encapsulates the means of interaction with user, E-mail or SMS notifications.
    \item \textbf{Business Logic.} Directly handles previously validated request.
    \item \textbf{Data Access Layer.} Responsible for logging, database access among other services required to support
    Business Logic layer.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Pictures/Monolith_architecture.pdf}
    \caption{Monolithic architecture diagram.}\label{fig:figure2}
\end{figure}

\subsection{Monolithic Architecture: Cons and Props}\label{subsec:monolith-architecture:-cons-and-props}

A monolith is built as a large system with a single code base and deployed as a single unit, usually behind a load balancer.
Monoliths offer several advantages, particularly when it comes to operational overhead requirements.
Here are some of those basic benefits:

\begin{itemize}
    \item \textbf{Simplicity.} Monolithic architectures are simple to build and deploy.
    These applications can scale horizontally, by running several copies of the application behind a load balancer.
    With a single codebase, monolithic apps can easily handle cross-cutting concerns, such as logging,
    configuration management and performance monitoring.
    Another advantage associated with the simplicity of monolithic applications is easier deployment.
    When it comes to monolithic applications, you do not have to handle many deployments but just one.
    \item \textbf{Performance.} Components in a monolith typically share memory which is faster than service-to-service
    communications using IPC [\cite{proctor1999linux}] or other mechanisms.
    \item \textbf{Easier debugging and testing.}
    In contrast to the microservices, monolithic applications are much easier to debug and test.
    Since that monolithic application is a single indivisible unit the process of end-to-end testing is much faster.
    \item \textbf{Easier development.} As long as the monolithic approach is a standard way of building applications,
    any engineering team has the right knowledge and capabilities to develop a monolithic application.
\end{itemize}

However, the drawback of monolithic architectures hides in their tight coupling.
Over time, monolithic components and layers become tightly coupled and entangled, effecting management, scalability
and continuous deployment.
Another disadvantages of the monoliths include:
\begin{itemize}
    \item \textbf{Understanding.} When a monolithic application's code base grows up, it becomes too complicated to understand.
    Obviously, huge code base of monolithic app is hard to manage therefore.
    \item \textbf{Reliability.} Entire application down may be caused by an error in every single component.
    \item \textbf{Updates.} Single and large code base causes the needs to redeploy an application on every single update.
    \item \textbf{Technology stack.} Technology stack of the monolithic app is limited by the technologies and providers
    used from the beginning of development.
    It makes technology stack changes to be expensive in terms of finances and time.
    \item \textbf{Scalability.} Application's components cannot be scaled independently, an entire application should be scaled.
\end{itemize}

\subsection{Minimization of coupling using CQRS}\label{subsec:decoupling-monolith-using-cqrs}
As we see, monolith has its own disadvantages, like for instance: understanding the project structure, reliability concerns,
technology stack limitations, scalability limitations.
Obviously, some of these disadvantages cannot be mitigated.
However, the complexity and coupling problem can be minimized applying Command-Query Responsibility Segregation (CQRS)
principle.
Violation of single-responsibility principle of SOLID causes the over-complication of codebase.
In general, service layer components keep the huge number of methods in order to handle all possible CRUD requests
to database.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Pictures/Services}
    \caption{CQRS Conceptual diagram.
    Source: \href{https://martinfowler.com/bliki/CQRS.html}{Martin Fowler}.}\label{fig:figure9}
\end{figure}
As it stated in previous section, monolithic architecture provides a quite strong coupling between application
components.
Moreover, as monolith grow horizontally, its services layer grows as well.
This process leads to very huge code base which is very difficult to support and extend.
We attach the following
\href{https://github.com/smartstore/SmartStoreNET/blob/4.x/src/Presentation/SmartStore.Web/Controllers/CatalogHelper.cs}
{link}
as an example of such approach.
To avoid the natural results of monolithic architecture, that are huge classes for thousands lines, we have to dive into
design patterns [\cite{rising1998design}].
Precisely, the mediator design pattern would help to decouple the service layer from presentation layer.
Mediator -- is a behavioral design pattern [\cite{rasche2016building}] that lets you reduce chaotic dependencies between objects.
The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.
In other words, mediator allows the communication between two entities, such that entities doesn't know each other.
The Mediator pattern suggests that you should cease all direct communication between the components which you want to make
independent of each other.
Instead, these components must collaborate indirectly, by calling a special mediator object that redirects the calls to
appropriate components.
As a result, the components depend only on a single mediator class instead of being coupled to dozens of their colleagues.
In context of .NET platform there are multiple implementation of the Mediator, the most widely known and used is the
\href{https://github.com/jbogard/MediatR}{MediatR}, which we use in our project.
Another, yet popular approach is the CQRS, which stands for Command-Query Responsibility Segregation.
In brief, it stands that read (query) and write (command) requests should be segregated by their responsibilities.
The CQRS approach in couple with Mediator pattern greatly helps to solve the coupling problem of the monolith architecture.
CQRS is a pattern that first described by Greg Young [\cite{young2010cqrs}].

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Pictures/cqrs.pdf}
    \caption{CQRS Conceptual diagram.
    Source: \href{https://martinfowler.com/bliki/CQRS.html}{Martin Fowler}.}
    \label{fig:figure}
\end{figure}

\begin{enumerate}
    \item User makes a change in UI\@.
    \item Application routes information to command model.
    \item Command model executes validation and business logic.
    \item Command model updates the database.
    \item Query model reads from database.
    \item Query service update presentation from query model.
\end{enumerate}

Despite these benefits, you should be very cautious about using CQRS\@.
Many information systems fit well with the notion of an information base that is updated in the same way that it's read,
adding CQRS to such a system can add significant complexity.
I've certainly seen cases where it's made a significant drag on productivity, adding an unwarranted amount of risk to the
project, even in the hands of a capable team.
So while CQRS is a pattern that's good to have in the toolbox, beware that it is difficult to use well and you can easily
chop off important bits if you mishandle it.

As a short conclusion, we may state that CQRS and Mediator pattern will not entirely solve the coupling problems the monolith,
however will make project much more simplistic and intuitively understood.
It is worth to keep is simple,
even relatively simple project may grow to the sizes of universe without proper architectural solutions.

Over whole data entities, we prefer to use universally unique identifier (UUID) or namely globally unique identifier (GUID),
a 128-bit label used for information in computer systems [\cite{leach2005universally}].
Simply, because it does not force us to keep a sequence on database side.
Sequence -- is a special entity provided in PostgreSQL relational databases.
It is responsible for generating unique values and sometimes causes a problems during migration of the database.
But still, are GUID identifiers are really always unique?
Well, each generated GUID is not guaranteed to be unique, the total number of unique keys $2^{128}$ or $3.4 \times 10^{38}$
is so large that the probability of the same number being generated twice is very small.
For example, consider the observable universe, which contains about $5 \times 10^{22}$ stars.
Every star could then have $6.8 \times 10^{15}$ universally unique GUIDs.
If you are scared of the same GUID values then put two of them next to each other.
If you are too paranoid then put three [\cite{GUIDSo}].