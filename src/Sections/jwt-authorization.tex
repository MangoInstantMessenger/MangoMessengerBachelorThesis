\subsection{JWT Authorization}\label{subsec:jwt-authorization}
In authentication, when the user successfully logs in using their credentials, a JSON Web Token will be returned.
Since tokens are credentials, great care must be taken to prevent security issues.
In general, you should not keep tokens longer than required.
You also should not store sensitive session data in browser storage due to lack of security.
Whenever the user wants to access a protected route or resource, the user agent should send the JWT,
typically in the Authorization header using the Bearer schema.
The content of the header should look like the following:
\begin{spverbatim}

    Authorization: Bearer <token>

\end{spverbatim}
This can be, in certain cases, a stateless authorization mechanism.
The server's protected routes will check for a valid JWT in the Authorization header, and if it's present,
the user will be allowed to access protected resources.
If the JWT contains the necessary data, the need to query the database for certain operations may be reduced,
though this may not always be the case.
If the token is sent in the Authorization header, Cross-Origin Resource Sharing (CORS) won't be an issue
as it doesn't use cookies.
Generally, the workflow is as follows
% old
\begin{enumerate}
    \item User provides credentials in order to authenticate to the system.
    \item Server verifies user's authentication, fetches the login and password in database.
    \item If authentication is successful, server creates session then writes this session to the database,
    see table session in [REFERENCE\_DATABASE\_SCHEMA].
    \item Server generates a pair of access token (JWT) and refresh token (GUID).
    \item Server sends to client access token and refresh token.
    \item Client saves the pair of access and refresh tokens.
    \item User requests resource using received token passed to the request header.
    \item The server check user's claims and proceeds or declines request.
\end{enumerate}

The eighth point is the authorization.
As a result, token stored on the client and used when it is necessary to authorize the requests.
When a hacker tries to replace the data in the header or payload the token will become invalid,
therefore the signature will not match the original values.
So, the hacker hasn't any possibility to generate a new signature since that encryption secret key stored on the server.
Access token (JWT) is used for request authorization and for storing the additional information about user like identifier,
display name and others.
Refresh Token (GUID) issued by server based on successful authentication results and used for get new access/refresh
token pair.
Also, it is worth to add a few basic rules about JWT secure usage [\cite{RDegges}]
\begin{itemize}
    \item JWT should have a short lifetime, since it cannot be revoked.
    \item JWT should be used in a single time, e.g JWT per request.
\end{itemize}
Therefore, we consider access token's lifetime to be 5 minutes and refresh token's 7 days.

For each request client preliminarily checks access token's lifetime.
If access token it expired, client sends request for updating a pair of access/refresh tokens.
For more confidence, we can update tokens a few seconds earlier.
That is, the case when the API receives an expired access token is practically excluded.
However, we are able to consider the case of interception of the request on 401 http response code,
that is unauthorized.
The following diagram demonstrates the process of requesting the resource

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Pictures/jwt_auth_scheme.pdf}
    \caption{JWT Authentication concept diagram.}\label{fig:figure3}
\end{figure}

By steps, the process is
\begin{itemize}
    \item \textbf{Step 1.} \textbf{Client} application sends \textbf{POST} authentication request to \textbf{/login} endpoint
    provided user credentials in request body.
    \item \textbf{Step 2.} Server responses to the client with the following HTTP response codes:
    \begin{itemize}
        \item \textbf{409Conflict}: Invalid credentials.
        \item \textbf{200Success}: Returns a pair of access and refresh tokens.
        \begin{itemize}
            \item \textbf{Step 3.} Server generates a pair of access and refresh tokens
            \begin{itemize}
                \item API fetches user data and claims.
                \item Server creates new session instance in database.
                \item Access token's \textbf{Header} Base64 encoded.
                \item Access token's \textbf{Payload} with user claims is Base64 encoded.
                \item Access token's \textbf{Signature} is generated using encoded token's Header and Payload signed by means of the
                algorithm from the header and secret:
                \begin{spverbatim}
                    HMACSHA256(
                    base64UrlEncode(header) + "." +
                    base64UrlEncode(payload),
                    secret)
                \end{spverbatim}
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item \textbf{Step 4.} Access token in serialized form and refresh token (GUID) returned in response with
    HTTP \textbf{200Success} code to the \textbf{Client}.
    \item \textbf{Step 5.} \textbf{Client} queries the \textbf{API / Microservice} providing access token as
    \textbf{Bearer} in request header.
    \item \textbf{Step 6.} \textbf{API / Microservice} validates the token claims in order to authorize user
    \begin{itemize}
        \item If authorized: \textbf{API / Microservice} does business logics and returns response \textbf{(Step 7)}.
        \item Otherwise: returns \textbf{401Unauthorized} response code.
    \end{itemize}
    \item \textbf{Step 7.} \textbf{API / Microservice} returns response \textbf{200Success} or \textbf{409Conflict}
    to the client according to backend business logic.
\end{itemize}